<html>
<body>
	<style>
	body {
		font-family: monospace;
		font-size: 24px;
		background: #333;
		color: #eee;
		overflow: auto;
	}

	div {
		/*font-size: 40px;*/
		text-align: center;
		font-size: 5vmin;
		/*3.0vh;*/
		/*5.9vw;*/
	}

	#canvas_container {
		display: flex;
		align-content: center;
		justify-content: center;
		align-items: center;
		height: 100%;
	}
	</style>

	<!--
		TODOs

		centeralign timing.
		count contractions.
		visualize contractions.

		put all events into a stream,
		reduce that.
		if needed, optimize.

		stream vs imperative
		- imperative computes immediately
		- stream defers computation
		- finally, they both require computation
		- if it's a running, state machines might be more efficient.

		TODO add touch support
	-->

	
	<!--<button onclick="start()">Start</button>
	<button onclick="stop()">Stop</button>-->
	<div style="z-index: 20; position: absolute; width: 100%; height: 100%;">
		<div id="canvas_container"></div>
	</div>

	<div id="info" style="display: flex; align-items: center; justify-content: center; height: 100%; flex-direction: column;">
		<div id="reps" style="color: yellowgreen; font-size: 2em">Max Hold</div>
		<div id="statusLabel" style="color: yellow">Hit Enter to Start / Stop</div>
		<div id="remaining" style="color: red">Tap Space for Contractions</div>
	</div>

	</div>

	<script>
		history = [
			{"time":1486052070298,"hold":45,"rest":15,"reptitions":10},
		]

		started = -1;
		marker = -1;
		currentReps = 0;

		events = [];
		mode = 'hold';

		statusLabel = document.getElementById('statusLabel');

		initCanvas();
		setInterval(interval, 15);

		window.addEventListener('resize', resize);

		function resize() {
			const smaller = Math.min(window.innerWidth, window.innerHeight);
			canvas.width = smaller;
			canvas.height = smaller;

			canvas.style.width = smaller;
			canvas.style.height = smaller;
		}

		function initCanvas() {
			canvas = document.createElement('canvas');
			canvas_container.appendChild(canvas);
			canvas.width = 800;
			canvas.height = 800;

			ctx = canvas.getContext('2d');
		}


		sessions = [];
		try {
			sessions = JSON.parse(localStorage.apnea_sessions);
		}
		catch (e) {

		}

		const keydowns = {};
		document.addEventListener('keydown', onkeydown);
		document.addEventListener('keyup', onkeyup);
		function onkeydown(e) {
			if (e.key !== ' ') return;
			if (keydowns[e.key]) return;
			keydowns[e.key] = 1;
			// emit event
			events.push({
				type: 'contraction_start',
				time: Date.now()
			});
		}

		function contraction_count() {
			return events.filter(e => e.type === 'contraction_start').length;
		}

		function contraction_first() {
			const first = events.find(e => e.type === 'contraction_start');
			if (!first) return -1;
			const lapse = first.time - started;
			return lapse;
		}

		function contraction_avg_interval() {
			// TODO
		}

		function contraction_avg_duration() {
			// TODO
		}

		function onkeyup(e) {
			if (e.key === 'Enter') {
				if (started > 0)
					stop();
				else
					start();
			}

			if (e.key !== ' ') return;
			keydowns[e.key] = 0;
			// emit event
			events.push({
				type: 'contraction_stop',
				time: Date.now()
			});
		}


		function start() {
			// TODO add count down
			started = Date.now();
			ending = started;
			events.push({
				type: 'started',
				time: started
			});

			info.style.display = 'none';
		}

		function stop() {
			now = Date.now()
			events.push({
				type: 'end',
				time: now
			});
			
			stats = `Contraction Count: ${contraction_count()}
First Contration: ${format(contraction_first())}
Timing: ${format(now - started)}`

			console.log(stats);

			ok = confirm(`${stats}
			Save?`);
			// TODO ask about session.

			if (ok) {
				sessions.push(events);
				localStorage.apnea_sessions = JSON.stringify(sessions);
			}

			started = -1;
			events = [];
			info.style.display = 'flex';
		}

		function interval() {
			const now = Date.now();
			
			time = now - started
			seconds = time / 1000 % 60;

			// update canvas
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.beginPath();

			ctx.strokeStyle = '#222';
			radius = canvas.width * 0.45;
			// console.log(radius);
			ring(radius, 1);

			if (started < 0) return;

			ctx.strokeStyle = mode === 'rest' ? 'yellow': '#ddd'; // red
			ring(radius, seconds / 60);

			// durationLabel.innerHTML = format(time)
			label(format(time));


			ctx.font = '12px monospace'
			contract = events.filter(e => e.type === 'contraction_start').map(e => format(e.time - started)).join('\n');
			ctx.fillText(contract, canvas.width / 2, canvas.height * 2 / 3);

		}

		function label(text) {
			// var text = ctx.measureText('foo'); // TextMetrics object
			// text.width; // 16;
			ctx.font = '20vmin monospace'; // 120px
			ctx.fillStyle = 'greenyellow';
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle'; // "top" || "hanging" || "middle" || "alphabetic" || "ideographic" || "bottom";
			ctx.fillText(text, canvas.width / 2, canvas.height / 2);
		}

		function ring(radius, t) {
			ctx.lineWidth = radius / 20;
			ARC_OFFSET = - Math.PI / 2;

			ctx.beginPath();
			ctx.arc(canvas.width / 2, canvas.height / 2, radius, ARC_OFFSET, Math.PI * 2 * t + ARC_OFFSET, false);
			ctx.stroke();
		}

		function format(lapse) {
			const ms = '.' + (lapse % 1000 / 100 | 0);
			const total_s = lapse / 1000 | 0;
			const s = total_s % 60;
			const min = total_s / 60 | 0;

			return `${pad(min, 1)}:${pad(s)}${ms}`;
		}

		function pad(value, digits=2) {
			const string = value + '';
			return Array(Math.max(digits - string.length,0)).fill('0').join('') + string;
		}
	</script>
</body>
</html>
